
// =====================
// TESTIMONIALS SLIDER
// =====================
const sliderTrack = document.getElementById("sliderTrack");
if (sliderTrack) {
  // Duplicate for infinite scroll visual
  sliderTrack.innerHTML += sliderTrack.innerHTML;
}

// =====================
// CHAT LOGIC
// =====================
chatToggleBtn?.addEventListener("click", () => {
    chatWidget.classList.remove("hidden");
    chatToggleBtn.classList.add("hidden");
    loadMessages();
    startChatPolling();
});

chatCloseBtn?.addEventListener("click", () => {
    chatWidget.classList.add("hidden");
    chatToggleBtn.classList.remove("hidden");
    stopChatPolling();
});

chatSendBtn?.addEventListener("click", sendMessage);
chatInput?.addEventListener("keydown", (e) => {
    if (e.key === "Enter") sendMessage();
});

async function sendMessage() {
    const content = chatInput.value.trim();
    if (!content || !currentParcelId) return;

    // Optimistic UI
    appendMessage({ sender: "user", content }, true);
    chatInput.value = "";

    try {
        await fetch(`${BASE_URL}/api/support/messages`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                parcelId: currentParcelId,
                sender: "user",
                content
            })
        });
        loadMessages(); // Sync
    } catch (err) {
        // console.error(err);
    }
}

async function loadMessages() {
    if (!currentParcelId) return;
    try {
        const res = await fetch(`${BASE_URL}/api/support/messages/${currentParcelId}`);
        const msgs = await safeJson(res);
        renderMessages(msgs);
    } catch (err) {
        console.error(err);
    }
}

function renderMessages(msgs) {
    if (!Array.isArray(msgs)) return;
    
    // Only rebuild if count changes to avoid flicker or sophisticated diffing
    // For now simple rebuild is fine for small chats
    const currentCount = chatBody.querySelectorAll('.chat-msg').length;
    if (msgs.length === currentCount) return;

    chatBody.innerHTML = "";
    
    // Intro message
    const intro = document.createElement("div");
    intro.style.textAlign = "center";
    intro.style.fontSize = "11px";
    intro.style.opacity = "0.6";
    intro.style.padding = "10px";
    intro.innerText = "Support connected";
    chatBody.appendChild(intro);

    msgs.forEach(msg => appendMessage(msg, false));
    chatBody.scrollTop = chatBody.scrollHeight;
}

function appendMessage(msg, scroll = true) {
    const div = document.createElement("div");
    // Admin/Superadmin = admin style
    const isAdmin = msg.sender === "admin" || msg.sender === "superadmin";
    div.className = `chat-msg ${isAdmin ? "admin" : "user"}`;
    div.textContent = msg.content;
    
    // If append mode vs rebuild
    // verify not duplicate if optimistic? 
    // In this simple implementation, loadMessages wipes and rebuilds, so duplicates are transient
    
    chatBody.appendChild(div);
    if (scroll) chatBody.scrollTop = chatBody.scrollHeight;
}

function startChatPolling() {
    stopChatPolling();
    chatInterval = setInterval(loadMessages, 3500);
}

function stopChatPolling() {
    if (chatInterval) clearInterval(chatInterval);
}
